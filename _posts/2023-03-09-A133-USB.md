---
layout:     post
title:      A133 USB
subtitle:   USB 触摸失灵问题
date:       2023-03-09
author:     LXG
header-img: img/post-bg-keybord.jpg
catalog: true
tags:
    - usb
---

## USB HUB 芯片

[汤铭科技股份有限公司](https://www.edomtech.com.cn/manufacturers-detail/terminus/)

![usb_hub_fe21](/images/usb/usb_hub_fe21.png)

![a133_usb_hub](/images/usb/a133_usb_hub.png)

## USB 驱动程序框架

Linux 内核提供了完整的 USB 驱动程序框架。USB 总线采用树形结构，在一条总线上只能有唯一的主机设备。Linux 内核从主机和设备两个角度观察 USB 总线结构。下图是 Linux 内核从主机和设备两个角度观察 USB 总线结构的示意图。

![usb_arch](/images/usb/usb_arch.png)

USB 子系统主要任务包括：
1. 注册和管理设备驱动；
2. USB 设备寻找驱动，并初始化和配置设备；
3. 内核中表现设备的树形结构；
4. 与设备交互。

## 驱动源码

```txt

kernel/linux-4.9/drivers/usb$ tree -L 1
.
├── atm
├── built-in.o
├── c67x00
├── chipidea
├── class
├── common
├── core                     // usb核心代码
├── dwc2
├── dwc3
├── early
├── gadget                  // usb device功能配置代码，如adb、mtp或hid等
├── host                    // AW平台控制器代码
├── image
├── isp1760
├── Kconfig
├── Makefile
├── misc
├── modules.builtin
├── modules.order
├── mon
├── musb
├── phy
├── README
├── renesas_usbhs
├── serial
├── storage
├── sunxi_usb               // AW平台otg、host与device功能自动切换管理代码
├── usbip
├── usb-skeleton.c
└── wusbcore

```

## 问题

**USB 相机插入导致触摸设备无法使用**

```txt

[   75.666757] usb 1-1.6: reset full-speed USB device number 5 using sunxi-ehci
[   75.860082] usb 1-1.5: new high-speed USB device number 7 using sunxi-ehci
[   76.040593] uvcvideo: Found UVC 1.00 device USB2.0_CAM1 (2c7f:4a60)
[   76.098066] input: USB2.0_CAM1 as /devices/platform/soc/5200000.ehci1-controller/usb1/1-1/1-1.5/1-1.5:1.0/input/input7

```

**分析**

```txt

Bus 001 Device 008: ID 2c7f:4a60           // usb 1-1.5 usb 相机设备
Bus 001 Device 001: ID 1d6b:0002
Bus 001 Device 003: ID 0bda:8152
Bus 001 Device 002: ID 1a40:0201
Bus 001 Device 005: ID 222a:0001           // usb 1-1.6 触摸状态 ILITEK-TP
Bus 002 Device 001: ID 1d6b:0001
Bus 001 Device 006: ID 2c7c:6002

```

**日志源码**

kernel/linux-4.9/drivers/usb/core/hub.c

```txt

static int
hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
                int retry_counter)
{
        -------------------------------------------------------------------

        if (udev->speed < USB_SPEED_SUPER)
                dev_info(&udev->dev,
                                "%s %s USB device number %d using %s\n",
                                (udev->config) ? "reset" : "new", speed,
                                devnum, udev->bus->controller->driver->name);

        -------------------------------------------------------------------
}

```

## 命令行重连usb设备

```txt

// 先解绑
echo '1-1.6' > sys/bus/usb/drivers/usb/unbind

// 再绑定
echo '1-1.6' > sys/bus/usb/drivers/usb/bind

```







































